<!DOCTYPE html>
<html lang="ja">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>ちいさなえほんメーカー（カメラなげなわ切り抜き＋トゥーン）</title>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<style>
:root{
  --bg:#f2f3f5;
  --stage:#ffffff;
  --panel:#ffffffdd;
  --ink:#222;
}
*{box-sizing:border-box}
body{
  margin:0;
  background:var(--bg);
  font-family:"M PLUS Rounded 1c",system-ui,-apple-system,BlinkMacSystemFont,Segoe UI;
  color:var(--ink);
  -webkit-tap-highlight-color:transparent;
}

/* ヘッダツールバー */
.palette{
  position:sticky;top:0;z-index:30;
  display:flex;flex-wrap:wrap;gap:8px;align-items:center;
  margin:8px;padding:10px 12px;border-radius:40px;
  background:var(--panel);backdrop-filter:blur(8px);
  border:1px solid #e8e8e8; box-shadow:0 6px 18px rgba(0,0,0,.12)
}
.btn{
  appearance:none;border:none;border-radius:999px;
  padding:8px 14px;font-weight:600;cursor:pointer;background:#fff;
  box-shadow:0 2px 0 rgba(0,0,0,.06); border:1px solid #eee;
  font-size:13px;
}
.icon{
  padding:6px 10px;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:4px;
}
.icon svg{
  width:22px;
  height:22px;
  display:block;
  stroke:#444;
  fill:none;
  stroke-width:1.9;
  stroke-linecap:round;
  stroke-linejoin:round;
}
.btn.on{
  outline:3px solid #92d8ff;
}
.btn.on.icon svg{
  stroke:#1a73e8;
}
.btn.icon:hover svg{
  stroke:#111;
}
.btn.primary{
  background:linear-gradient(#ffdede,#ffbbbb);
}
.chip{
  padding:6px 10px;border-radius:999px;background:#fff;border:1px solid #eee;
  font-size:12px;
}

/* ステージ全体 */
main{display:flex;gap:12px;padding:16px}
@media(max-width:1000px){ main{flex-direction:column} }
.book-wrap{display:flex;justify-content:center;width:100%;}
.book-stage{
  position:relative;
  display:inline-block;
  /* ここを変更 */
  background:transparent;    /* 白いカード背景をやめる */
  box-shadow:none;           /* 影も消す */
  border-radius:0;           /* 角丸も消す */
  overflow:visible;          /* 本の端が切れないように */
}


/* 左右のページ送りボタン（三角） */
.pageNavBtn{
  position:absolute;
  top:50%;
  transform:translateY(-50%);
  width:40px;
  height:72px;
  border-radius:999px;
  background:#ffffff;
  border:1px solid #ddd;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  box-shadow:0 4px 12px rgba(0,0,0,.16);
  padding:0;
}
.pageNavBtn.left{ left:4px; }
.pageNavBtn.right{ right:4px; }
.pageNavBtn svg{
  width:20px;
  height:20px;
  stroke:#555;
  fill:none;
  stroke-width:2;
  stroke-linecap:round;
  stroke-linejoin:round;
}

/* 内部キャンバス */
canvas{display:block;touch-action:none}
#bg,#tint,#obj,#paint{
  position:absolute;
  left:26px;top:26px;
}

/* おえかき設定パネル */
#drawPanel{
  position:fixed;
  left:16px;
  top:80px;
  z-index:260;
  padding:10px 12px;border-radius:14px;
  background:#ffffffee;backdrop-filter:blur(6px);border:1px solid #eee;
  box-shadow:0 8px 18px rgba(0,0,0,.12);
  display:none;width:340px;max-width:90vw;
}
#drawPanel.open{display:block}
.row{display:flex;align-items:center;gap:10px;margin:6px 0}
.row label{min-width:5em;color:#333;font-weight:700}

/* フルスクリーン読みきかせ */
#fs{position:fixed;inset:0;background:#000;display:none;z-index:200}
#fs.show{display:block}
#fsCanvas{width:100vw;height:100vh;background:#000;touch-action:none}
#fsBtns{position:absolute;left:0;right:0;bottom:20px;display:flex;justify-content:center;gap:12px}
#fsBtns .btn{font-size:18px;padding:10px 16px}
.recLamp{
  width:12px;height:12px;border-radius:50%;
  background:#aaa;display:inline-block;margin-left:4px;
}
.recLamp.on{background:#e53935;box-shadow:0 0 10px #e53935}

/* カメラモーダル＋なげなわ＋映像設定 */
#camModal{
  position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;z-index:250;
  align-items:center;justify-content:center;padding:16px;
}
#camModal.show{display:flex}
.camCard{
  position:relative;background:#fff;border-radius:16px;overflow:hidden;
  width:min(920px,96vw);height:min(70vh,75vw);box-shadow:0 14px 30px rgba(0,0,0,.28)
}
.camHead{
  display:flex;gap:8px;align-items:center;justify-content:space-between;
  padding:10px 12px;border-bottom:1px solid #eee;background:#fafafa
}
.camBody{position:relative;height:calc(100% - 52px)}
#camVideo{
  position:absolute;inset:0;width:100%;height:100%;
  object-fit:contain;background:#000;visibility:hidden;
}
#camView,#camOverlay{
  position:absolute;inset:0;
}
#camOverlay{touch-action:none;}
.camBtns{display:flex;gap:8px}
.small{font-size:12px;font-weight:700;border:1px solid #e5e5e7}

/* 映像設定パネル（カメラ内） */
.camVideoPanel{
  position:absolute;right:8px;top:8px;
  background:rgba(0,0,0,.75);color:#eee;font-size:11px;
  padding:6px 8px;border-radius:8px;max-width:220px;z-index:5;
}
.camVideoPanel .title{font-weight:700;margin-bottom:4px;font-size:11px}
.camVideoPanel label{display:flex;align-items:center;gap:4px;margin-bottom:3px;white-space:nowrap}
.camVideoPanel input[type="range"]{flex:1}
.camVideoPanel input[type="checkbox"]{margin-right:2px}

/* カメラセレクタ */
.camSelect{
  max-width:220px;
  padding:4px 6px;
  border-radius:999px;
  border:1px solid #ddd;
  font-size:12px;
}

/* 右クリックメニュー（画像複製／削除／ペースト） */
#imgMenu{
  position:fixed;
  z-index:400;
  background:#fff;
  border-radius:8px;
  border:1px solid #ddd;
  box-shadow:0 8px 20px rgba(0,0,0,.25);
  display:none;
  padding:4px 0;
  font-size:13px;
}
#imgMenu button{
  display:block;
  width:100%;
  background:none;
  border:none;
  text-align:left;
  padding:6px 14px;
  cursor:pointer;
}
#imgMenu button:hover{
  background:#f2f7ff;
}
</style>

<body>
<!-- ヘッダ -->
<div class="palette">
  <!-- ツール順：ペン → 消しゴム → 設定 → 画像編集 → カメラ -->
  <button id="mDraw" class="btn icon" title="ペンでおえかき">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M4 20l3.5-0.5L19 8l-3-3L4.5 16.5 4 20z"></path>
      <path d="M14 5l3 3"></path>
    </svg>
  </button>
  <button id="eraserToggle" class="btn icon" title="消しゴムで消す">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M7 19h10"></path>
      <path d="M4 14l6-6 4 0 6 6-4 4H8z"></path>
    </svg>
  </button>
  <button id="openDrawPanel" class="btn icon" title="おえかきの細かい設定">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <circle cx="8" cy="12" r="1.2"></circle>
      <circle cx="12" cy="8" r="1.2"></circle>
      <circle cx="16" cy="12" r="1.2"></circle>
      <path d="M12 4.5a7 7 0 0 1 6.5 4.4 4 4 0 0 1-3.9 5.1H9.5A4.5 4.5 0 0 1 5 9.5 5 5 0 0 1 12 4.5z"></path>
    </svg>
  </button>
  <button id="mImg" class="btn icon" title="貼り付けた画像を動かす・回す・大きさ変更">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <rect x="4" y="5" width="16" height="14" rx="2"></rect>
      <circle cx="9" cy="10" r="1.6"></circle>
      <path d="M6 17l3.5-3.5 2.5 2.5 3.5-4 3.5 5"></path>
    </svg>
  </button>
  <button id="openCam" class="btn icon" title="カメラでなげなわ切り抜き">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <rect x="4" y="7" width="16" height="11" rx="2"></rect>
      <path d="M9 7l1.5-2h3L15 7"></path>
      <circle cx="12" cy="13" r="3"></circle>
    </svg>
  </button>

  <span class="chip" title="いま開いている見開きページ">
    ページ <span id="pageLabel">表紙</span>（<span id="pNow">1</span>/<span id="pAll">3</span>）
  </span>

  <button id="pPrev" class="btn icon" title="前の見開きへ">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M15 6l-6 6 6 6"></path>
    </svg>
  </button>
  <button id="pNext" class="btn icon" title="次の見開きへ">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M9 6l6 6-6 6"></path>
    </svg>
  </button>
  <button id="pAdd" class="btn icon" title="この見開きの次に見開きを追加">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <rect x="4" y="4" width="16" height="16" rx="2"></rect>
      <path d="M12 8v8"></path>
      <path d="M8 12h8"></path>
    </svg>
  </button>
  <button id="pDel" class="btn icon" title="この見開きを削除">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M6 7h12"></path>
      <path d="M10 7V5h4v2"></path>
      <rect x="7" y="7" width="10" height="12" rx="1.5"></rect>
      <path d="M10 11v5"></path>
      <path d="M14 11v5"></path>
    </svg>
  </button>

  <div style="flex:1"></div>

  <button id="recStart" class="btn icon" title="このページの音声を録音">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <rect x="9" y="5" width="6" height="10" rx="3"></rect>
      <path d="M7 11v1a5 5 0 0 0 10 0v-1"></path>
      <path d="M12 18v3"></path>
      <path d="M9 21h6"></path>
    </svg>
    <span id="lamp" class="recLamp"></span>
  </button>
  <button id="recStop" class="btn icon" title="録音を停止" disabled>
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <rect x="8" y="8" width="8" height="8" rx="1.5"></rect>
    </svg>
  </button>
  <button id="playPage" class="btn icon" title="このページの音声を再生">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M8 6v12l9-6z"></path>
    </svg>
  </button>
  <button id="saveAudio" class="btn icon" title="このページの音声ファイルを保存">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M12 3v12"></path>
      <path d="M8 11l4 4 4-4"></path>
      <rect x="5" y="15" width="14" height="4" rx="1.5"></rect>
    </svg>
  </button>
  <button id="fsOpen" class="btn icon" title="全画面で読みきかせモード">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M4 6.5c1.6-.8 3.4-1.5 5.5-1.5s3.9.4 5.5 1.1"></path>
      <path d="M4 17.5c1.6-.8 3.4-1.5 5.5-1.5s3.9.4 5.5 1.1"></path>
      <path d="M12 5v12"></path>
      <path d="M19 6v11"></path>
    </svg>
  </button>
  <button id="savePdf" class="btn icon primary" title="えほん全体をPDFで保存">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <rect x="5" y="3" width="14" height="18" rx="2"></rect>
      <path d="M9 7h3"></path>
      <path d="M9 11h6"></path>
      <path d="M9 15h4"></path>
    </svg>
  </button>
</div>

<!-- おえかき設定（ノート上に浮かせる） -->
<div id="drawPanel">
  <div class="row">
    <label>ブラシ</label>
    <select id="brushMode">
      <option value="crayon" selected>クレヨン</option>
      <option value="watercolor">水彩</option>
    </select>
  </div>
  <div class="row" id="wcRow">
    <label>にじみ</label>
    <input type="range" id="wcWet" min="0" max="100" value="45">
    <span id="wcWetView">45%</span>
  </div>
  <div class="row">
    <label>ペン色</label>
    <input type="color" id="penColorInput" value="#3b7f3b">
  </div>
  <div class="row">
    <label>太さ</label>
    <input type="range" id="penSizeInput" min="2" max="60" value="22">
    <span id="penSizeView">22px</span>
  </div>
  <div class="row">
    <label>背景色</label>
    <input type="color" id="pageBgColor" value="#ffffff">
    <label style="min-width:auto">透明度</label>
    <input type="range" id="pageBgAlpha" min="0" max="100" value="0">
    <span id="alphaView">0%</span>
  </div>
  <small style="color:#555">背景色は見開き単位で設定（PDF/フルスクリーンに反映）。</small>
</div>

<!-- 本のステージ -->
<main>
  <section class="book-wrap">
    <div id="stage" class="book-stage">
      <!-- 左右のページ送りボタン（三角） -->
      <button id="pSidePrev" class="pageNavBtn left" title="前の見開きへ">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M15 6l-6 6 6 6"></path>
        </svg>
      </button>
      <button id="pSideNext" class="pageNavBtn right" title="次の見開きへ">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M9 6l6 6-6 6"></path>
        </svg>
      </button>

      <canvas id="bg"></canvas>
      <canvas id="tint"></canvas>
      <canvas id="obj"></canvas>
      <canvas id="paint"></canvas>
    </div>
  </section>
</main>

<!-- カメラ・モーダル（なげなわ切り抜き＋映像設定＋トゥーン） -->
<div id="camModal">
  <div class="camCard">
    <div class="camHead">
      <div class="camBtns">
        <button id="camClose" class="btn small" title="カメラを閉じる">閉じる</button>
      </div>
      <div class="camBtns">
        <select id="camSelect" class="camSelect" title="使うカメラを選びます"></select>
        <button id="camRefresh" class="btn small" title="カメラ一覧を更新">更新</button>
      </div>
    </div>
    <div class="camBody">
      <video id="camVideo" playsinline autoplay muted></video>
      <canvas id="camView"></canvas>
      <canvas id="camOverlay"></canvas>

      <!-- 映像設定パネル -->
      <div class="camVideoPanel">
        <div class="title">映像設定</div>
        <label>明るさ
          <input id="camBrightness" type="range" min="0.2" max="2" step="0.01" value="1">
        </label>
        <label>コントラスト
          <input id="camContrast" type="range" min="0.5" max="2" step="0.01" value="1">
        </label>
        <label>露出
          <input id="camExposure" type="range" min="-2" max="2" step="0.1" value="0">
        </label>
        <label>色温度
          <input id="camColorTemp" type="range" min="-1" max="1" step="0.1" value="0">
        </label>
        <label>シャープ
          <input id="camSharp" type="range" min="0" max="1" step="0.1" value="0">
        </label>
        <label>
          <input id="camToon" type="checkbox">
          トゥーンシェーディング
        </label>
        <div style="margin-top:3px;white-space:normal;color:#ddd">
          ※なげなわで囲って指／マウスを離すと自動で切り抜いて貼り付けます。<br>
          ※トゥーンONで教科書イラスト風の映像になります。
        </div>
      </div>
    </div>
  </div>
</div>

<!-- フルスクリーン読みきかせ -->
<div id="fs">
  <canvas id="fsCanvas"></canvas>
  <div id="fsBtns">
    <button id="fsPrev" class="btn" title="前のページへ">◀ 前</button>
    <button id="fsPlay" class="btn" title="このページの音声を再生">▶ 音声</button>
    <button id="fsAuto" class="btn" title="ページを自動で進めながら再生">⏯ 自動再生</button>
    <button id="fsNext" class="btn" title="次のページへ">次 ▶</button>
    <button id="fsExit" class="btn" title="読みきかせを終了">閉じる</button>
  </div>
</div>

<!-- 右クリックメニュー -->
<div id="imgMenu">
  <button data-act="dup">複製</button>
  <button data-act="del">削除</button>
  <button data-act="paste">ペースト</button>
</div>

<script>
/* ========= 基本寸法 ========= */
const PAGE=480, GUT=0, W=PAGE*2, H=PAGE;
const bgCvs  = document.getElementById("bg");
const tintCvs= document.getElementById("tint");
const objCvs = document.getElementById("obj");
const paintCvs=document.getElementById("paint");
[bgCvs,tintCvs,objCvs,paintCvs].forEach(c=>{c.width=W;c.height=H;});
const stage=document.getElementById("stage");
const bg = bgCvs.getContext("2d");
const tc = tintCvs.getContext("2d");
const oc = objCvs.getContext("2d");
const pc = paintCvs.getContext("2d");

/* ステージレイアウト */
function layoutStage(){
  const outerW = Math.min(window.innerWidth - 32, 1040);
  const innerW = outerW - 52;
  const innerH = innerW * (H / W);
  const outerH = innerH + 52;
  stage.style.width  = outerW + "px";
  stage.style.height = outerH + "px";
  [bgCvs,tintCvs,objCvs,paintCvs].forEach(c=>{
    c.style.width  = innerW + "px";
    c.style.height = innerH + "px";
  });
}
layoutStage();
window.addEventListener('resize', layoutStage);

/* ========= 紙の質感＋真ん中だけ折り目 ========= */

function rr(ctx,x,y,w,h,r){
  ctx.beginPath(); ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}
/* ========= 紙の質感＋本っぽい背景 ========= */
let _paper = null;
function paperPat(){
  if(_paper) return _paper;
  const t = document.createElement("canvas");
  t.width = 480; t.height = 480;
  const c = t.getContext("2d");
  c.fillStyle = "#fdfdfd";
  c.fillRect(0,0,480,480);
  for(let i=0;i<380;i++){
    c.fillStyle = `rgba(0,0,0,${(Math.random()*0.04).toFixed(3)})`;
    c.fillRect(Math.random()*480, Math.random()*480, 1, 1);
  }
  _paper = bg.createPattern(t,"repeat");
  return _paper;
}

// 本のページ形状用パス（上も下も同じ向きにふくらむ）
function pageShapePath(ctx, x0, x1, top, bottom, newPath = true){
  const mid = (x0 + x1) / 2;

  if (newPath) ctx.beginPath();

  // 上端（中央が少し上がる）
  ctx.moveTo(x0, top + 6);
  ctx.quadraticCurveTo(mid, top - 10, x1, top + 6);

  // 右辺
  ctx.lineTo(x1, bottom - 6);

  // 下端（中央が少し上がる＝上端と同じ向き）
  ctx.quadraticCurveTo(mid, bottom - 14, x0, bottom - 6);

  if (newPath) ctx.closePath();
}
// 左右2ページ分をまとめてクリップするヘルパー
function clipToPages(ctx){
  const margin  = 42;
  const top     = 36;
  const bottom  = H - 40;
  const leftX0  = margin;
  const leftX1  = W/2 - 1;
  const rightX0 = W/2 + 1;
  const rightX1 = W - margin;

  ctx.beginPath();
  // left / right を同じパスの中に描く（newPath=false）
  pageShapePath(ctx, leftX0,  leftX1,  top, bottom, false);
  pageShapePath(ctx, rightX0, rightX1, top, bottom, false);
  ctx.clip();
}


function drawBG(){
  const w = W;
  const h = H;
  bg.clearRect(0,0,w,h);

  const margin  = 42;
  const top     = 36;
  const bottom  = h - 40;

  // ページ位置（先に計算しておく）
  const leftX0  = margin;
  const leftX1  = w/2 - 1;
  const rightX0 = w/2 + 1;
  const rightX1 = w - margin;

  const spineX       = w / 2;                     // 本の中央（背）
  const leftMidPage  = (leftX0  + leftX1) / 2;   // 左ページ中央
  const rightMidPage = (rightX0 + rightX1) / 2;  // 右ページ中央

  /* ---- 黒い表紙（上下カーブ＋下端は W 字カーブ）---- */
  const coverLeft   = margin - 10;
  const coverRight  = w - (margin - 10);
  const coverTop    = top + 10;
  const coverBottom = bottom + 20;
  const coverTopMid = (coverLeft + coverRight) / 2;

  // 下端の基準高さと「上がる」「下がる」量
  const yOuter = coverBottom - 10;   // 左右の端の高さ（基準）
  const yUp    = yOuter - 5;       // ページ中央で少し上に反る位置
  const yDown  = yOuter + 5;        // 本の背で少し下がる位置

  bg.fillStyle = "#111";
  bg.beginPath();

  // 上端（シンプルに中央がちょっと上にふくらむ）
  bg.moveTo(coverLeft, coverTop + 5);
  bg.quadraticCurveTo(coverTopMid, coverTop - 5, coverRight, coverTop + 5);

  // 右側面を下へ
  bg.lineTo(coverRight, yOuter);

  // --- 下端：W 字カーブ ---
  // 右端 → 右ページ中央（上にふくらむ）
  bg.quadraticCurveTo(rightX1 + 20, yDown-10, rightMidPage, yUp);

  // 右ページ中央 → 本の背（少し下がる）
  bg.quadraticCurveTo((rightMidPage + spineX) / 2, yDown-10 , spineX, yDown-3);

  // 本の背 → 左ページ中央（また上にふくらむ）
  bg.quadraticCurveTo((leftMidPage + spineX) / 2, yDown-10 , leftMidPage, yUp);

  // 左ページ中央 → 左端（基準高さにもどる）
  bg.quadraticCurveTo(leftX0 - 20, yDown-10, coverLeft, yOuter);

  // 左側面を上へ戻る
  bg.lineTo(coverLeft, coverTop + 6);

  bg.closePath();
  bg.fill();

  /* ---- 白いページ（紙テクスチャ＋カーブ）---- */
  bg.save();
  bg.fillStyle = paperPat();

  pageShapePath(bg, leftX0,  leftX1,  top, bottom);
  bg.fill();

  pageShapePath(bg, rightX0, rightX1, top, bottom);
  bg.fill();
  bg.restore();

  // ---- ページの外枠線 ----
  bg.strokeStyle = "#222";
  bg.lineWidth = 2;
  pageShapePath(bg, leftX0,  leftX1,  top, bottom);
  bg.stroke();
  pageShapePath(bg, rightX0, rightX1, top, bottom);
  bg.stroke();

  // ---- 中央のとじ目 ----
  bg.strokeStyle = "rgba(0,0,0,0.5)";
  bg.lineWidth = 1.5;
  bg.beginPath();
  bg.moveTo(w/2, top + 10);
  bg.lineTo(w/2, bottom - 12);
  bg.stroke();

  // ---- 表紙の側面の影 ----
  bg.strokeStyle = "rgba(0,0,0,0.25)";
  bg.lineWidth = 3;
  bg.beginPath();
  bg.moveTo(leftX0 - 1, top + 4);
  bg.lineTo(leftX0 - 1, bottom - 8);
  bg.stroke();
  bg.beginPath();
  bg.moveTo(rightX1 + 1, top + 4);
  bg.lineTo(rightX1 + 1, bottom - 8);
  bg.stroke();
}


drawBG();


/* ========= 見開きデータ ========= */
function newSpread(type='normal'){
  return { type, paintOff:null, objs:[], audioBlob:null, audioURL:null, audioExt:'',
           tint:{color:'#ffffff', alpha:0} };
}
let spreads=[newSpread('cover'), newSpread('normal'), newSpread('back')];
let cur=0;

/* 背景色レイヤ */
function drawTint(){
  tc.clearRect(0,0,W,H);
  const {color,alpha} = spreads[cur].tint;
  if(!color || alpha <= 0) return;

  const margin  = 42;
  const top     = 36;
  const bottom  = H - 40;
  const leftX0  = margin;
  const leftX1  = W/2 - 4;
  const rightX0 = W/2 + 4;
  const rightX1 = W - margin;

  tc.save();
  tc.globalAlpha = Math.max(0, Math.min(1, alpha));
  tc.fillStyle = color;

  pageShapePath(tc, leftX0,  leftX1,  top, bottom);
  tc.fill();

  pageShapePath(tc, rightX0, rightX1, top, bottom);
  tc.fill();

  tc.restore();
}


/* ページ保存/読込/ラベル */
function saveCur(){
  const off=document.createElement("canvas"); off.width=W; off.height=H;
  off.getContext("2d").drawImage(paintCvs,0,0);
  spreads[cur].paintOff=off;
}
function loadSpread(i){
  cur=i;
  pc.clearRect(0,0,W,H);
  if(spreads[cur].paintOff) pc.drawImage(spreads[cur].paintOff,0,0);
  drawTint();
  redrawObjs();
  updatePageLabel();
  syncTintUI();
}
const pageLabelEl = document.getElementById('pageLabel');
const pNow = document.getElementById('pNow');
const pAll = document.getElementById('pAll');
function spreadLabel(sp,i){
  if(sp.type==='cover') return '表紙';
  if(sp.type==='back')  return '裏表紙';
  let n=0; for(const s of spreads){ if(s.type==='normal'){ n++; if(s===sp) return String(n); } }
  return String(i);
}
function updatePageLabel(){
  pageLabelEl.textContent = spreadLabel(spreads[cur], cur);
  pNow.textContent = (cur+1);
  pAll.textContent = spreads.length;
}
function syncTintUI(){
  const t = spreads[cur].tint;
  pageBgColor.value = t.color || '#ffffff';
  pageBgAlpha.value = Math.round((t.alpha||0)*100);
  alphaView.textContent = pageBgAlpha.value + '%';
}

/* ========= ドロー（ブラシ＋消しゴム） ========= */
const mDraw = document.getElementById('mDraw');
const mImg  = document.getElementById('mImg');
const eraserToggle = document.getElementById('eraserToggle');
const drawPanel = document.getElementById('drawPanel');
const openDrawPanelBtn = document.getElementById('openDrawPanel');

let mode='draw';
let erasing=false;
paintCvs.style.pointerEvents = 'auto';
objCvs.style.pointerEvents   = 'none'; // イベントは paint 側に集約

function updateToolHighlights(){
  mDraw.classList.toggle('on', mode==='draw' && !erasing);
  eraserToggle.classList.toggle('on', mode==='draw' && erasing);
  mImg.classList.toggle('on', mode==='edit');
}
updateToolHighlights();

function setMode(m){
  mode=m;
  if(mode==='edit'){ erasing=false; }
  updateToolHighlights();
}
function setErase(v){
  erasing = v;
  if(erasing && mode!=='draw') mode='draw';
  updateToolHighlights();
}

mDraw.onclick = ()=>{ hideDrawPanel(); setMode('draw'); setErase(false); };
mImg.onclick  = ()=>{ hideDrawPanel(); setMode('edit'); };
eraserToggle.onclick = ()=>{ hideDrawPanel(); setErase(!erasing); };

const penColorInput = document.getElementById('penColorInput');
const penSizeInput  = document.getElementById('penSizeInput');
const penSizeView   = document.getElementById('penSizeView');
const pageBgColor   = document.getElementById('pageBgColor');
const pageBgAlpha   = document.getElementById('pageBgAlpha');
const alphaView     = document.getElementById('alphaView');
openDrawPanelBtn.onclick=()=> drawPanel.classList.toggle('open');

let penColor='#3b7f3b', penSize=22;
penColorInput.oninput = (e)=>{ penColor = e.target.value; setErase(false); };
penSizeInput.oninput  = (e)=>{ penSize = +e.target.value; penSizeView.textContent = penSize+'px'; };
pageBgColor.oninput   = ()=>{ spreads[cur].tint.color = pageBgColor.value; drawTint(); };
pageBgAlpha.oninput   = ()=>{ spreads[cur].tint.alpha = (+pageBgAlpha.value)/100; alphaView.textContent = pageBgAlpha.value+'%'; drawTint(); };

/* 他のボタンを押したらおえかき設定パネルを閉じる */
function hideDrawPanel(){ drawPanel.classList.remove('open'); }
document.addEventListener('click', (e)=>{
  const btn = e.target.closest('button');
  if(!btn) return;
  if(btn === openDrawPanelBtn) return;
  hideDrawPanel();
});

/* ブラシ（水彩/クレヨン） */
const brushModeSel = document.getElementById('brushMode');
const wcRow = document.getElementById('wcRow');
const wcWetInput   = document.getElementById('wcWet');
const wcWetView    = document.getElementById('wcWetView');
let brushMode = 'crayon';
let wcWet = 0.45;
brushModeSel.oninput = () => {
  brushMode = brushModeSel.value;
  wcRow.style.opacity = (brushMode==='watercolor') ? 1 : .4;
};
wcWetInput.oninput = (e) => { wcWet = (+e.target.value)/100; wcWetView.textContent = e.target.value+'%'; };

let _wcTex = null;
function makeWatercolorTexture(){
  if (_wcTex) return _wcTex;
  const t = document.createElement('canvas');
  t.width = t.height = 128;
  const c = t.getContext('2d');
  const g = c.createRadialGradient(64,64,10, 64,64,64);
  g.addColorStop(0,'rgba(0,0,0,1)');
  g.addColorStop(.6,'rgba(0,0,0,.22)');
  g.addColorStop(1,'rgba(0,0,0,0)');
  c.fillStyle=g; c.fillRect(0,0,128,128);
  for(let i=0;i<900;i++){
    const x=(Math.random()*128)|0, y=(Math.random()*128)|0;
    const a=0.03+Math.random()*0.04;
    c.fillStyle=`rgba(0,0,0,${a})`; c.fillRect(x,y,1,1);
  }
  _wcTex = t; return t;
}
function stampWatercolor(ctx, x1,y1, x2,y2, color, size, wet){
  const tex = makeWatercolorTexture();
  const step = Math.max(1, size * 0.32);
  const len  = Math.hypot(x2-x1, y2-y1) || 1;
  const nx = (x2-x1)/len, ny = (y2-y1)/len;

  const buf = document.createElement('canvas');
  const bctx = buf.getContext('2d');

  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  const baseAlpha = 0.18 + wet * 0.32;

  for (let d = 0; d <= len; d += step) {
    const px = x1 + nx*d + (Math.random()-0.5)*size*0.08;
    const py = y1 + ny*d + (Math.random()-0.5)*size*0.08;
    const s  = size * (0.88 + Math.random()*0.28);
    const a  = baseAlpha * (0.85 + Math.random()*0.3);

    buf.width = buf.height = s|0;
    bctx.clearRect(0,0,buf.width,buf.height);
    bctx.drawImage(tex, 0,0,buf.width,buf.height);
    bctx.globalCompositeOperation = 'source-in';
    bctx.fillStyle = color;
    bctx.fillRect(0,0,buf.width,buf.height);
    bctx.globalCompositeOperation = 'source-over';

    ctx.globalAlpha = a;
    const ang = Math.random() * Math.PI * 2;
    ctx.translate(px,py);
    ctx.rotate(ang);
    ctx.drawImage(buf, -buf.width/2, -buf.height/2);
    ctx.rotate(-ang);
    ctx.translate(-px,-py);
  }
  ctx.restore();
}
function pos(canvas,e){
  const r=canvas.getBoundingClientRect();
  const src = e.touches ? e.touches[0] : e.changedTouches ? e.changedTouches[0] : e;
  const cx=src.clientX, cy=src.clientY;
  const x=(cx-r.left)*(canvas.width/r.width);
  const y=(cy-r.top)*(canvas.height/r.height);
  return {x,y};
}
function line(x1,y1,x2,y2){
  // ページの内側だけ描けるようにクリップ
  pc.save();
  clipToPages(pc);

  if (erasing){
    const step=Math.max(1,penSize*0.32);
    const len=Math.hypot(x2-x1,y2-y1)||1;
    pc.globalCompositeOperation='destination-out';
    for(let d=0; d<=len; d+=step){
      const px=x1+(x2-x1)/len*d, py=y1+(y2-y1)/len*d;
      pc.beginPath(); pc.arc(px,py,penSize*0.5,0,Math.PI*2); pc.fill();
    }
    pc.globalCompositeOperation='source-over';
  } else {
    if (brushMode==='watercolor'){
      stampWatercolor(pc, x1,y1, x2,y2, penColor, penSize*1.25, wcWet);
    } else {
      pc.strokeStyle = penColor;
      pc.lineWidth   = penSize;
      pc.lineCap='round'; pc.lineJoin='round';
      pc.beginPath(); pc.moveTo(x1,y1); pc.lineTo(x2,y2); pc.stroke();
    }
  }

  pc.restore();
}

let isDraw=false,lx=0,ly=0;
function dStart(e){
  isDraw=true;
  const p=pos(paintCvs,e);
  lx=p.x; ly=p.y;
  e.preventDefault();
}
function dMove(e){
  if(!isDraw) return;
  const p=pos(paintCvs,e);
  line(lx,ly,p.x,p.y); lx=p.x; ly=p.y;
  e.preventDefault();
}
function dEnd(){ isDraw=false; }

/* ========= 画像オブジェクト（移動／回転／拡大）＋自動編集切替 ========= */
function redrawObjs(){
  oc.clearRect(0,0,W,H);
  spreads[cur].objs.forEach((o,i)=>{
    oc.save(); oc.translate(o.cx,o.cy); oc.rotate(o.theta); oc.scale(o.scale,o.scale);
    oc.drawImage(o.img, -o.w/2, -o.h/2);
    oc.restore();
    if(i===sel && mode==='edit') drawGizmo(o);
  });
}
function drawGizmo(o){
  const hw=o.w*o.scale/2, hh=o.h*o.scale/2, a=o.theta;
  const rot=(p)=>({x:o.cx+p.x*Math.cos(a)-p.y*Math.sin(a), y:o.cy+p.x*Math.sin(a)+p.y*Math.cos(a)});
  const corners=[{x:-hw,y:-hh},{x:hw,y:-hh},{x:hw,y:hh},{x:-hw,y:hh}].map(rot);
  oc.save();
  oc.strokeStyle='#2b7bff'; oc.lineWidth=2; oc.setLineDash([8,6]);
  oc.beginPath(); oc.moveTo(corners[0].x,corners[0].y); for(let i=1;i<4;i++) oc.lineTo(corners[i].x,corners[i].y); oc.closePath(); oc.stroke(); oc.setLineDash([]);
  corners.forEach(p=>{ oc.fillStyle='#fff'; oc.beginPath(); oc.rect(p.x-6,p.y-6,12,12); oc.fill(); oc.stroke(); });
  const topMid={x:(corners[0].x+corners[1].x)/2, y:(corners[0].y+corners[1].y)/2};
  const hx=topMid.x+Math.cos(o.theta-Math.PI/2)*30, hy=topMid.y+Math.sin(o.theta-Math.PI/2)*30;
  oc.beginPath(); oc.moveTo(topMid.x,topMid.y); oc.lineTo(hx,hy); oc.stroke();
  oc.beginPath(); oc.arc(hx,hy,8,0,Math.PI*2); oc.fill(); oc.stroke();
  oc.restore();
}
function local(o,px,py){
  const dx=px-o.cx, dy=py-o.cy, c=Math.cos(-o.theta), s=Math.sin(-o.theta);
  return {x:(dx*c-dy*s)/o.scale, y:(dx*s+dy*c)/o.scale};
}
function hitRotate(o,px,py){
  const hw=o.w*o.scale/2, hh=o.h*o.scale/2, a=o.theta;
  const rot=(p)=>({x:o.cx+p.x*Math.cos(a)-p.y*Math.sin(a), y:o.cy+p.x*Math.sin(a)+p.y*Math.cos(a)});
  const corners=[{x:-hw,y:-hh},{x:hw,y:-hh},{x:hw,y:hh},{x:-hw,y:hh}].map(rot);
  const topMid={x:(corners[0].x+corners[1].x)/2, y:(corners[0].y+corners[1].y)/2};
  const hx=topMid.x+Math.cos(o.theta-Math.PI/2)*30, hy=topMid.y+Math.sin(o.theta-Math.PI/2)*30;
  return Math.hypot(px-hx,py-hy) < 12;
}
function hitCorner(o,px,py){
  const p=local(o,px,py), m=10/o.scale, hw=o.w/2, hh=o.h/2;
  if(Math.abs(p.x-hw)<m&&Math.abs(p.y+hh)<m) return 0;
  if(Math.abs(p.x-hw)<m&&Math.abs(p.y-hh)<m) return 1;
  if(Math.abs(p.x+hw)<m&&Math.abs(p.y-hh)<m) return 2;
  if(Math.abs(p.x+hw)<m&&Math.abs(p.y+hh)<m) return 3;
  return -1;
}

let sel=-1, action=null, dragOff={x:0,y:0}, rotStart={ang:0,theta:0}, scaleStart={d:0,s:1};
let lastRightClickPos={x:W/2,y:H/2};
let clipboardTemplate=null;

/* 統合キャンバスイベント（paint 上で画像判定＋お絵かき） */
function canvasDown(e){
  const isTouch = e.type.startsWith('touch');
  const button = isTouch ? 0 : e.button;
  if(button === 2) return; // 右クリックは contextmenu で処理
  const p = pos(paintCvs,e);

  // まず画像ヒット判定（上にあるもの優先）
  let hitIndex=-1, hitOnRotate=false;
  for(let i=spreads[cur].objs.length-1;i>=0;i--){
    const o=spreads[cur].objs[i];
    const lp=local(o,p.x,p.y);
    const inside = Math.abs(lp.x)<=o.w/2 && Math.abs(lp.y)<=o.h/2;
    const onRot  = hitRotate(o,p.x,p.y);
    if(inside || onRot){
      hitIndex=i;
      hitOnRotate = onRot && !inside;
      break;
    }
  }

  if(hitIndex>=0){
    // 画像上を左クリック → 自動的に画像編集モードへ
    if(mode!=='edit') setMode('edit');
    sel = hitIndex;
    const o = spreads[cur].objs[sel];

    if(hitOnRotate || hitRotate(o,p.x,p.y)){
      action='rotate';
      rotStart.ang=Math.atan2(p.y-o.cy,p.x-o.cx);
      rotStart.theta=o.theta;
    } else {
      const c=hitCorner(o,p.x,p.y);
      if(c>=0){
        action='scale';
        scaleStart.d=Math.hypot(p.x-o.cx,p.y-o.cy);
        scaleStart.s=o.scale;
      } else {
        action='move';
        dragOff.x=p.x-o.cx; dragOff.y=p.y-o.cy;
      }
    }
    isDraw=false; // お絵かき中ならキャンセル
    redrawObjs();
    e.preventDefault();
    return;
  }

  // 画像に当たっていない → 描画モードならお絵かき開始
  sel = -1;
  redrawObjs();
  if(mode==='draw'){
    dStart(e);
  }
}
function canvasMove(e){
  const isTouch = e.type.startsWith('touch');
  const buttons = isTouch ? 1 : e.buttons;

  if(action && sel>=0 && (buttons & 1 || isTouch)){
    const p=pos(paintCvs,e);
    const o=spreads[cur].objs[sel];
    if(action==='move'){
      o.cx=p.x-dragOff.x; o.cy=p.y-dragOff.y;
    }else if(action==='scale'){
      const d=Math.hypot(p.x-o.cx,p.y-o.cy);
      o.scale=Math.max(0.05,Math.min(10, scaleStart.s*d/Math.max(1,scaleStart.d)));
    }else if(action==='rotate'){
      let d=Math.atan2(p.y-o.cy,p.x-o.cx)-rotStart.ang;
      if(e.shiftKey && !isTouch){ const step=Math.PI/12; d=Math.round(d/step)*step; }
      o.theta=rotStart.theta+d;
    }
    redrawObjs();
    e.preventDefault();
    return;
  }

  if(isDraw && mode==='draw'){
    dMove(e);
  }
}
function canvasUp(e){
  if(action){
    action=null;
  }
  if(isDraw && mode==='draw'){
    dEnd(e);
  }
}

paintCvs.addEventListener('mousedown', canvasDown);
paintCvs.addEventListener('mousemove', canvasMove);
paintCvs.addEventListener('mouseup',   canvasUp);
paintCvs.addEventListener('mouseleave',canvasUp);
paintCvs.addEventListener('touchstart',canvasDown,{passive:false});
paintCvs.addEventListener('touchmove', canvasMove,{passive:false});
paintCvs.addEventListener('touchend',  canvasUp,{passive:false});
paintCvs.addEventListener('touchcancel',canvasUp,{passive:false});

/* ========= カメラ＋なげなわ切り抜き＋映像設定＋トゥーン ========= */
const camModal = document.getElementById('camModal');
const camVideo = document.getElementById('camVideo');
const camView  = document.getElementById('camView');
const camOverlay = document.getElementById('camOverlay');
const viewCtx = camView.getContext('2d');
const ctxOL = camOverlay.getContext('2d');
const btnOpenCam = document.getElementById('openCam');
const btnCamClose = document.getElementById('camClose');
const camSelect = document.getElementById('camSelect');
const camRefresh = document.getElementById('camRefresh');

/* 映像設定UI */
const camBrightness = document.getElementById('camBrightness');
const camContrast   = document.getElementById('camContrast');
const camExposure   = document.getElementById('camExposure');
const camColorTemp  = document.getElementById('camColorTemp');
const camSharp      = document.getElementById('camSharp');
const camToon       = document.getElementById('camToon');

let camStream=null;
let currentCamDeviceId=null;
let isLassoDrawing=false;
let lassoPath=[];

// なげなわ＆映像処理用キャンバス
const camComposite = document.createElement('canvas');
const camCompCtx   = camComposite.getContext('2d');

// 映像設定状態
const camSettings = {
  brightness: 1,
  contrast:   1,
  exposure:   0,
  colorTemp:  0,
  sharpness:  0,
  toon:       false
};
let camFilterString = 'brightness(1) contrast(1)';

function updateCamFilter(){
  const exposureFactor = Math.pow(2, camSettings.exposure);
  const b = camSettings.brightness * exposureFactor;
  const c = camSettings.contrast;

  let f = `brightness(${b}) contrast(${c})`;
  const t = camSettings.colorTemp;
  if (t > 0){
    const amt = t;
    f += ` sepia(${amt}) saturate(${1 + 0.5 * amt}) hue-rotate(-10deg)`;
  }else if (t < 0){
    const amt = -t;
    f += ` saturate(${1 - 0.3 * amt}) hue-rotate(${amt * 20}deg)`;
  }
  camFilterString = f;
  camVideo.style.filter = f;
}
updateCamFilter();

function applySharpenToImage(img, amount){
  if(amount<=0) return;
  const w=img.width,h=img.height,data=img.data;
  const src=new Uint8ClampedArray(data);
  const center=5 + 4*amount;

  const kernel=[
    0,-1,0,
    -1,center,-1,
    0,-1,0
  ];
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const idx=(y*w+x)*4;
      let r=0,g=0,b=0; let ki=0;
      for(let ky=-1;ky<=1;ky++){
        for(let kx=-1;kx<=1;kx++){
          const idx2=((y+ky)*w+(x+kx))*4;
          const wgt=kernel[ki++];
          r+=src[idx2]*wgt;
          g+=src[idx2+1]*wgt;
          b+=src[idx2+2]*wgt;
        }
      }
      data[idx]     = Math.max(0,Math.min(255,r));
      data[idx + 1] = Math.max(0,Math.min(255,g));
      data[idx + 2] = Math.max(0,Math.min(255,b));
    }
  }
}
function applyToonShading(img, levels=4, edgeThreshold=80){
  const w=img.width,h=img.height,data=img.data;
  const gray=new Float32Array(w*h);
  for(let i=0,px=0;i<data.length;i+=4,px++){
    const r=data[i],g=data[i+1],b=data[i+2];
    gray[px]=0.299*r+0.587*g+0.114*b;
  }
  const step=255/levels;
  for(let i=0,px=0;i<data.length;i+=4,px++){
    const g0 = gray[px];
    const gq = Math.floor(g0/step)*step + step*0.5;
    const ratio = g0>0 ? gq/g0 : 1;
    let r=data[i]*ratio, g=data[i+1]*ratio, b=data[i+2]*ratio;
    data[i]  = Math.max(0,Math.min(255,r));
    data[i+1]= Math.max(0,Math.min(255,g));
    data[i+2]= Math.max(0,Math.min(255,b));
  }
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const idx=y*w+x;
      const gx =
        -gray[idx-w-1] -2*gray[idx-1] -gray[idx+w-1] +
         gray[idx-w+1] +2*gray[idx+1] +gray[idx+w+1];
      const gy =
        -gray[idx-w-1] -2*gray[idx-w] -gray[idx-w+1] +
         gray[idx+w-1] +2*gray[idx+w] +gray[idx+w+1];
      const mag=Math.sqrt(gx*gx+gy*gy);
      if(mag>edgeThreshold){
        const di=idx*4;
        data[di]=data[di+1]=data[di+2]=0;
      }
    }
  }
}
function postProcessCamFrame(){
  const w=camComposite.width,h=camComposite.height;
  if(!w||!h) return;
  if(camSettings.sharpness<=0 && !camSettings.toon) return;
  const img=camCompCtx.getImageData(0,0,w,h);
  if(camSettings.sharpness>0) applySharpenToImage(img, camSettings.sharpness);
  if(camSettings.toon)        applyToonShading(img, 4, 80);
  camCompCtx.putImageData(img,0,0);
}

/* 映像設定スライダのイベント */
camBrightness.oninput = ()=>{ camSettings.brightness=parseFloat(camBrightness.value)||1; updateCamFilter(); };
camContrast.oninput   = ()=>{ camSettings.contrast=parseFloat(camContrast.value)||1; updateCamFilter(); };
camExposure.oninput   = ()=>{ camSettings.exposure=parseFloat(camExposure.value)||0; updateCamFilter(); };
camColorTemp.oninput  = ()=>{ camSettings.colorTemp=parseFloat(camColorTemp.value)||0; updateCamFilter(); };
camSharp.oninput      = ()=>{ camSettings.sharpness=parseFloat(camSharp.value)||0; };
camToon.onchange      = ()=>{ camSettings.toon=camToon.checked; };

/* オーバーレイのリサイズ */
function sizeOverlay(){
  const parentRect = camOverlay.parentElement.getBoundingClientRect();
  const w = parentRect.width;
  const h = parentRect.height;
  if(!w || !h){
    requestAnimationFrame(sizeOverlay);
    return;
  }
  camOverlay.width  = w;
  camOverlay.height = h;
  camView.width     = w;
  camView.height    = h;
  camComposite.width  = w;
  camComposite.height = h;
  drawLassoOverlay();
}

/* カメラフレームをコンポジットキャンバスに描画（映像設定＋トゥーンを反映） */
function drawCamFrameToComposite(){
  const vw=camVideo.videoWidth, vh=camVideo.videoHeight;
  const cw=camComposite.width, ch=camComposite.height;
  if(!vw||!vh||!cw||!ch) return;

  const ctx=camCompCtx;
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,cw,ch);
  ctx.fillStyle='black'; ctx.fillRect(0,0,cw,ch);

  const s = Math.min(cw/vw, ch/vh);
  const rw = vw*s, rh = vh*s;
  const dx = (cw-rw)/2, dy = (ch-rh)/2;

  ctx.filter = camFilterString || 'none';
  ctx.translate(dx,dy);
  ctx.scale(s,s);
  ctx.drawImage(camVideo,0,0,vw,vh);
  ctx.restore();

  ctx.filter='none';
  postProcessCamFrame();

  if(camView.width && camView.height){
    viewCtx.clearRect(0,0,camView.width,camView.height);
    viewCtx.drawImage(camComposite,0,0,camView.width,camView.height);
  }
}

/* ライブプレビュー用ループ */
(function renderLoop(){
  if(camModal.classList.contains('show') && camStream && camVideo.readyState>=2){
    camVideo.style.visibility='visible';
    drawCamFrameToComposite();
  }
  requestAnimationFrame(renderLoop);
})();

/* なげなわ描画 */
function drawLassoOverlay(){
  ctxOL.clearRect(0,0,camOverlay.width,camOverlay.height);
  if(!lassoPath.length) return;
  ctxOL.save();
  ctxOL.fillStyle='rgba(0,0,0,.45)';
  ctxOL.fillRect(0,0,camOverlay.width,camOverlay.height);
  ctxOL.globalCompositeOperation='destination-out';
  ctxOL.beginPath();
  ctxOL.moveTo(lassoPath[0].x, lassoPath[0].y);
  for(let i=1;i<lassoPath.length;i++) ctxOL.lineTo(lassoPath[i].x,lassoPath[i].y);
  if(!isLassoDrawing) ctxOL.closePath();
  ctxOL.fill();
  ctxOL.restore();

  ctxOL.save();
  ctxOL.strokeStyle='#ffdd00';
  ctxOL.lineWidth=2;
  ctxOL.setLineDash([6,4]);
  ctxOL.beginPath();
  ctxOL.moveTo(lassoPath[0].x, lassoPath[0].y);
  for(let i=1;i<lassoPath.length;i++) ctxOL.lineTo(lassoPath[i].x,lassoPath[i].y);
  if(!isLassoDrawing) ctxOL.closePath();
  ctxOL.stroke();
  ctxOL.restore();
}
function camPos(e){
  const r=camOverlay.getBoundingClientRect();
  const src = e.touches ? e.touches[0] : e.changedTouches ? e.changedTouches[0] : e;
  const cx=src.clientX, cy=src.clientY;
  const x=(cx-r.left)*(camOverlay.width/r.width);
  const y=(cy-r.top)*(camOverlay.height/r.height);
  return {x,y};
}

/* なげなわ → 切り抜き＆自動貼り付け＋自動クローズ */
function createStickerFromLasso(){
  if(!camStream || !lassoPath.length || isLassoDrawing) return;
  const vw=camVideo.videoWidth, vh=camVideo.videoHeight;
  if(!vw||!vh) return;

  const cw=camComposite.width, ch=camComposite.height;
  if(!cw||!ch) return;

  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const p of lassoPath){
    if(p.x<minX)minX=p.x;
    if(p.y<minY)minY=p.y;
    if(p.x>maxX)maxX=p.x;
    if(p.y>maxY)maxY=p.y;
  }
  const minW = maxX-minX, minH = maxY-minY;
  if(minW<20 || minH<20){
    lassoPath=[]; drawLassoOverlay();
    return;
  }

  drawCamFrameToComposite();

  const pad = 4;
  minX = Math.max(0, minX - pad);
  minY = Math.max(0, minY - pad);
  maxX = Math.min(cw, maxX + pad);
  maxY = Math.min(ch, maxY + pad);

  const bw = Math.max(1, Math.round(maxX - minX));
  const bh = Math.max(1, Math.round(maxY - minY));

  const cut = document.createElement('canvas');
  cut.width = bw; cut.height = bh;
  const cctx = cut.getContext('2d');

  cctx.save();
  cctx.translate(-minX, -minY);
  cctx.beginPath();
  cctx.moveTo(lassoPath[0].x, lassoPath[0].y);
  for(let i=1;i<lassoPath.length;i++) cctx.lineTo(lassoPath[i].x,lassoPath[i].y);
  cctx.closePath();
  cctx.clip();
  cctx.drawImage(camComposite,0,0);
  cctx.restore();

  spreads[cur].objs.push({
    img: cut,
    w: bw, h: bh,
    cx: W/2, cy: H/2,
    scale: 1, theta: 0
  });
  sel = spreads[cur].objs.length-1;
  setMode('edit');
  redrawObjs();

  lassoPath=[]; isLassoDrawing=false; drawLassoOverlay();

  camModal.classList.remove('show');
  stopCam();
}

/* オーバーレイ入力 */
function olDown(e){
  if(!camStream) return;
  e.preventDefault();
  isLassoDrawing=true;
  lassoPath=[camPos(e)];
  drawLassoOverlay();
}
function olMove(e){
  if(!isLassoDrawing) return;
  e.preventDefault();
  const p=camPos(e);
  const last=lassoPath[lassoPath.length-1];
  if(!last || Math.hypot(p.x-last.x,p.y-last.y)>2){
    lassoPath.push(p);
    drawLassoOverlay();
  }
}
function olUp(e){
  if(!isLassoDrawing) return;
  e.preventDefault();
  isLassoDrawing=false;
  drawLassoOverlay();
  createStickerFromLasso();
}
['mousedown','touchstart'].forEach(ev=> camOverlay.addEventListener(ev, olDown, {passive:false}));
['mousemove','touchmove' ].forEach(ev=> camOverlay.addEventListener(ev, olMove,  {passive:false}));
['mouseup','mouseleave','touchend','touchcancel'].forEach(ev=> camOverlay.addEventListener(ev, olUp, {passive:false}));

/* カメラ起動／停止＋デバイス選択 */
async function populateCamList(){
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const vids = devices.filter(d=>d.kind==='videoinput');
    camSelect.innerHTML='';
    vids.forEach((d,idx)=>{
      const opt=document.createElement('option');
      opt.value=d.deviceId;
      opt.textContent=d.label || `カメラ ${idx+1}`;
      camSelect.appendChild(opt);
    });
    if(!currentCamDeviceId && vids[0]) currentCamDeviceId = vids[0].deviceId;
    if(currentCamDeviceId) camSelect.value = currentCamDeviceId;
  }catch(e){
    console.warn('enumerateDevices error', e);
  }
}
async function startCam(deviceId=null){
  try{
    if(camStream){ camStream.getTracks().forEach(t=>t.stop()); }
    const constraints = {
      video: deviceId ? {deviceId:{exact:deviceId}} : {width:{ideal:1280}, height:{ideal:720}}
    };
    camStream = await navigator.mediaDevices.getUserMedia(constraints);
    camVideo.srcObject = camStream;
    if(!deviceId){
      await populateCamList();
    }
  }catch(e){
    alert('カメラが利用できません：' + e.message);
  }
}
function stopCam(){
  try{ camStream?.getTracks().forEach(t=>t.stop()); }catch(_){}
  camStream=null;
}
camSelect.onchange = ()=>{
  currentCamDeviceId = camSelect.value || null;
  startCam(currentCamDeviceId);
};
camRefresh.onclick = async ()=>{
  await populateCamList();
};

/* モーダル開閉 */
btnOpenCam.onclick = async ()=>{
  hideDrawPanel();
  camModal.classList.add('show');
  lassoPath=[]; isLassoDrawing=false; drawLassoOverlay();
  await startCam(currentCamDeviceId);
  requestAnimationFrame(sizeOverlay);
};
btnCamClose.onclick = ()=>{
  camModal.classList.remove('show');
  stopCam();
};
window.addEventListener('resize', ()=>{
  if(camModal.classList.contains('show')) requestAnimationFrame(sizeOverlay);
});

/* ========= ページ制御（追加＋削除＋左右ボタン連動） ========= */
const pPrev = document.getElementById('pPrev');
const pNext = document.getElementById('pNext');
const pAdd  = document.getElementById('pAdd');
const pDel  = document.getElementById('pDel');
const pSidePrev = document.getElementById('pSidePrev');
const pSideNext = document.getElementById('pSideNext');

function goPrevSpread(){
  hideDrawPanel();
  if(cur>0){ saveCur(); loadSpread(cur-1); }
}
function goNextSpread(){
  hideDrawPanel();
  if(cur<spreads.length-1){ saveCur(); loadSpread(cur+1); }
}

function addSpreadAfterCurrent(){
  hideDrawPanel();
  saveCur();
  let insertIndex = cur + 1;
  if(insertIndex > spreads.length - 1) insertIndex = spreads.length - 1;
  insertIndex = Math.min(spreads.length - 1, insertIndex);
  spreads.splice(insertIndex, 0, newSpread('normal'));
  loadSpread(insertIndex);
}

pPrev.onclick     = goPrevSpread;
pSidePrev.onclick = goPrevSpread;
pNext.onclick     = goNextSpread;
pSideNext.onclick = goNextSpread;
pAdd.onclick      = addSpreadAfterCurrent;

pDel.onclick = ()=>{
  hideDrawPanel();
  const target = spreads[cur];
  if(target.type !== 'normal'){
    alert('表紙と裏表紙は削除できません。');
    return;
  }
  const normalCount = spreads.filter(s=>s.type==='normal').length;
  if(normalCount <= 1){
    alert('これ以上削除できません（見開きは少なくとも1つ必要です）。');
    return;
  }
  spreads.splice(cur,1);
  if(cur >= spreads.length) cur = spreads.length-1;
  loadSpread(cur);
};

updatePageLabel();
syncTintUI();

/* ========= 録音（ページごと） ========= */
const lamp = document.getElementById('lamp');
let mediaRecorder = null, chunks = [];
let currentMicStream = null;
function pickBestAudioMime() {
  const cand = [
    'audio/mp4;codecs=mp4a.40.2',
    'audio/mp4',
    'audio/webm;codecs=opus',
    'audio/webm'
  ];
  for (const m of cand) {
    try { if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m; } catch(_) {}
  }
  return '';
}
const bestMime = (window.MediaRecorder && typeof MediaRecorder !== 'undefined') ? pickBestAudioMime() : '';

const recStart = document.getElementById('recStart');
const recStop  = document.getElementById('recStop');
const playPage = document.getElementById('playPage');
recStart.onclick = async () => {
  hideDrawPanel();
  try {
    currentMicStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
    });
    try {
      mediaRecorder = bestMime ? new MediaRecorder(currentMicStream, { mimeType: bestMime })
                               : new MediaRecorder(currentMicStream);
    } catch (e) {
      mediaRecorder = new MediaRecorder(currentMicStream);
    }
    chunks = [];
    mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size>0) chunks.push(e.data); };
    mediaRecorder.onstop = ()=>{
      const outType = mediaRecorder.mimeType || bestMime || 'audio/webm';
      const blob = new Blob(chunks, { type: outType });
      if (spreads[cur].audioURL) URL.revokeObjectURL(spreads[cur].audioURL);
      spreads[cur].audioBlob = blob;
      spreads[cur].audioURL  = URL.createObjectURL(blob);
      spreads[cur].audioExt  = outType.startsWith('audio/mp4') ? '.m4a'
                           : outType.startsWith('audio/webm') ? '.webm' : '';
      try { currentMicStream?.getTracks().forEach(t=>t.stop()); } catch(_){}
      currentMicStream = null;
      lamp.classList.remove('on'); recStop.disabled=true; recStart.disabled=false;
      alert('このページの音声を保存しました（形式: '+(spreads[cur].audioExt||outType)+'）');
    };
    mediaRecorder.start();
    lamp.classList.add('on'); recStart.disabled=true; recStop.disabled=false;
  } catch (e) {
    alert('マイク権限を許可してください\n'+e);
  }
};
recStop.onclick=()=>{ hideDrawPanel(); if(mediaRecorder && mediaRecorder.state!=='inactive'){ mediaRecorder.stop(); } };
playPage.onclick=()=>{ hideDrawPanel(); const url=spreads[cur].audioURL; if(!url){alert('このページに音声はありません');return;} new Audio(url).play(); };
document.getElementById('saveAudio').onclick = ()=>{
  hideDrawPanel();
  const sp = spreads[cur];
  if(!sp.audioBlob){ alert('このページに音声はありません'); return; }
  const a = document.createElement('a');
  const label = spreadLabel(sp, cur).replace(/[^\p{L}\p{N}\-_.]/gu,'_');
  const ext = sp.audioExt || '.webm';
  a.href = sp.audioURL;
  a.download = `ehon_page_${label}${ext}`;
  a.click();
};

/* ========= フルスクリーン読みきかせ ========= */
const fs=document.getElementById('fs');
const fsCanvas=document.getElementById('fsCanvas');
const fsCtx=fsCanvas.getContext('2d');
let autoPlaying = false;
let currentAudio = null;

function fitFS(){ fsCanvas.width = window.innerWidth; fsCanvas.height= window.innerHeight; }
function drawFS(){
  fsCtx.fillStyle='#000'; fsCtx.fillRect(0,0,fsCanvas.width,fsCanvas.height);
  const comp=document.createElement("canvas"); comp.width=W; comp.height=H; const cc=comp.getContext("2d");
  drawBG(); cc.drawImage(bgCvs,0,0);
  const {color,alpha} = spreads[cur].tint;
  if(alpha>0){
    cc.save(); cc.globalAlpha=alpha; rr(cc,0,0,PAGE,PAGE,10); cc.clip(); cc.fillStyle=color; cc.fillRect(0,0,PAGE,PAGE); cc.restore();
    cc.save(); cc.globalAlpha=alpha; rr(cc,PAGE,0,PAGE,PAGE,10); cc.clip(); cc.fillStyle=color; cc.fillRect(PAGE,0,PAGE,PAGE); cc.restore();
  }
  spreads[cur].objs.forEach(o=>{ cc.save(); cc.translate(o.cx,o.cy); cc.rotate(o.theta); cc.scale(o.scale,o.scale); cc.drawImage(o.img,-o.w/2,-o.h/2); cc.restore(); });
  if(spreads[cur].paintOff) cc.drawImage(spreads[cur].paintOff,0,0); else cc.drawImage(paintCvs,0,0);
  const scale=Math.min(fsCanvas.width/W, fsCanvas.height/H);
  const dx=(fsCanvas.width - W*scale)/2, dy=(fsCanvas.height - H*scale)/2;
  fsCtx.save(); fsCtx.translate(dx,dy); fsCtx.scale(scale,scale); fsCtx.drawImage(comp,0,0); fsCtx.restore();
}
function playCurrentPageAudio(){
  stopCurrentAudio();
  const url = spreads[cur].audioURL;
  if(!url) return null;
  currentAudio = new Audio(url);
  currentAudio.play();
  return currentAudio;
}
function stopCurrentAudio(){ if(currentAudio){ currentAudio.pause(); currentAudio=null; } }
function fsGoToPage(i){ saveCur(); loadSpread(i); drawFS(); }
function nextPageFS(){ if(cur < spreads.length-1){ fsGoToPage(cur+1); playCurrentPageAudio(); } else { stopAutoPlay(); } }
function prevPageFS(){ if(cur > 0){ fsGoToPage(cur-1); playCurrentPageAudio(); }
}
const fsPrev = document.getElementById('fsPrev');
const fsNext = document.getElementById('fsNext');
const fsPlay = document.getElementById('fsPlay');
const fsAuto = document.getElementById('fsAuto');
const fsOpen = document.getElementById('fsOpen');
const fsExit = document.getElementById('fsExit');
fsPrev.onclick=()=>{ prevPageFS(); };
fsNext.onclick=()=>{ nextPageFS(); };
fsPlay.onclick=()=>{ playCurrentPageAudio(); };

function startAutoPlay(){
  autoPlaying = true;
  const a = playCurrentPageAudio();
  if(a){ a.onended = ()=> nextPageFS(); } else { nextPageFS(); }
}
function stopAutoPlay(){ autoPlaying=false; stopCurrentAudio(); }
fsAuto.onclick=()=>{ autoPlaying ? stopAutoPlay() : startAutoPlay(); };

function openFS(){
  hideDrawPanel();
  fs.classList.add('show');
  if(document.documentElement.requestFullscreen){ document.documentElement.requestFullscreen().catch(()=>{}); }
  fitFS(); drawFS(); playCurrentPageAudio();
}
function closeFS(){
  fs.classList.remove('show');
  stopAutoPlay();
  if(document.fullscreenElement){ document.exitFullscreen().catch(()=>{}); }
}
fsOpen.onclick=openFS; fsExit.onclick=closeFS;
window.addEventListener('resize', ()=>{ if(fs.classList.contains('show')){ fitFS(); drawFS(); } });

/* ========= PDF 保存 ========= */
const savePdf = document.getElementById('savePdf');
const {jsPDF}=window.jspdf;
savePdf.onclick=()=>{
  hideDrawPanel();
  saveCur();
  const pdf=new jsPDF({orientation:'landscape',unit:'px',format:[W,H]});
  spreads.forEach((sp,i)=>{
    const c=document.createElement('canvas'); c.width=W; c.height=H; const cx=c.getContext('2d');
    drawBG(); cx.drawImage(bgCvs,0,0);
    if(sp.tint && sp.tint.alpha>0){
  const margin  = 42;
  const top     = 36;
  const bottom  = H - 40;
  const leftX0  = margin;
  const leftX1  = W/2 - 4;
  const rightX0 = W/2 + 4;
  const rightX1 = W - margin;

  cx.save();
  cx.globalAlpha = Math.max(0, Math.min(1, sp.tint.alpha));
  cx.fillStyle   = sp.tint.color;

  pageShapePath(cx, leftX0,  leftX1,  top, bottom);
  cx.fill();

  pageShapePath(cx, rightX0, rightX1, top, bottom);
  cx.fill();

  cx.restore();
}

    sp.objs.forEach(o=>{ cx.save(); cx.translate(o.cx,o.cy); cx.rotate(o.theta); cx.scale(o.scale,o.scale); cx.drawImage(o.img,-o.w/2,-o.h/2); cx.restore(); });
    if(sp.paintOff) cx.drawImage(sp.paintOff,0,0);
    pdf.addImage(c.toDataURL('image/png'),'PNG',0,0,W,H);
    if(i<spreads.length-1) pdf.addPage([W,H],'landscape');
  });
  pdf.save('ehon.pdf');
};

/* ========= 画像用 右クリックメニュー（複製／削除／ペースト） ========= */
const imgMenu = document.getElementById('imgMenu');
const btnDup  = imgMenu.querySelector('[data-act="dup"]');
const btnDel  = imgMenu.querySelector('[data-act="del"]');
const btnPaste= imgMenu.querySelector('[data-act="paste"]');

let menuTargetIndex=-1;

function showImgMenu(x,y, mode){ // mode: 'obj' or 'blank'
  imgMenu.style.left = x + 'px';
  imgMenu.style.top  = y + 'px';
  if(mode==='obj'){
    btnDup.style.display   = 'block';
    btnDel.style.display   = 'block';
    btnPaste.style.display = clipboardTemplate ? 'block' : 'none';
  }else{
    btnDup.style.display   = 'none';
    btnDel.style.display   = 'none';
    btnPaste.style.display = clipboardTemplate ? 'block' : 'none';
    if(!clipboardTemplate) return;
  }
  imgMenu.style.display = 'block';
}
function hideImgMenu(){
  imgMenu.style.display='none';
  menuTargetIndex=-1;
}

paintCvs.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  hideImgMenu();
  const p = pos(paintCvs,e);
  lastRightClickPos = p;

  // どの画像の上か調べる
  let hitIndex=-1;
  for(let i=spreads[cur].objs.length-1;i>=0;i--){
    const o=spreads[cur].objs[i];
    const lp=local(o,p.x,p.y);
    if(Math.abs(lp.x)<=o.w/2 && Math.abs(lp.y)<=o.h/2){ hitIndex=i; break; }
  }
  menuTargetIndex = hitIndex;
  const mode = (hitIndex>=0) ? 'obj' : 'blank';
  showImgMenu(e.clientX, e.clientY, mode);
});

document.addEventListener('click', (e)=>{
  if(!e.target.closest('#imgMenu')) hideImgMenu();
});

btnDup.onclick = ()=>{
  if(menuTargetIndex<0) return;
  const src = spreads[cur].objs[menuTargetIndex];
  clipboardTemplate = {
    img: src.img,
    w: src.w, h: src.h,
    scale: src.scale,
    theta: src.theta
  };
  spreads[cur].objs.push({
    img: clipboardTemplate.img,
    w: clipboardTemplate.w,
    h: clipboardTemplate.h,
    scale: clipboardTemplate.scale,
    theta: clipboardTemplate.theta,
    cx: src.cx + 20,
    cy: src.cy + 20
  });
  sel = spreads[cur].objs.length-1;
  setMode('edit');
  redrawObjs();
  hideImgMenu();
};

btnDel.onclick = ()=>{
  if(menuTargetIndex<0) return;
  spreads[cur].objs.splice(menuTargetIndex,1);
  sel = -1;
  redrawObjs();
  hideImgMenu();
};

btnPaste.onclick = ()=>{
  if(!clipboardTemplate) return;
  const tpl = clipboardTemplate;
  spreads[cur].objs.push({
    img: tpl.img,
    w: tpl.w,
    h: tpl.h,
    scale: tpl.scale,
    theta: tpl.theta,
    cx: lastRightClickPos.x,
    cy: lastRightClickPos.y
  });
  sel = spreads[cur].objs.length-1;
  setMode('edit');
  redrawObjs();
  hideImgMenu();
};
</script>
</body>
</html>
